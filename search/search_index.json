{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Security Lab's documentation","text":""},{"location":"#quickstart","title":"Quickstart","text":"<p>Our SDK is currently organized in two main libraries: The base functionality in our Base SDK library and specific front-end components for React in our React SDK library.</p> <p>For code integration with our Base SDK, you can start by looking at our guides:</p> <ul> <li>Guide for using our Base SDK with React.</li> <li>Guide for using our Base SDK with React Native and Expo.</li> <li>Guide for using our Base SDK with node and express.</li> <li>Guide for using TBAs (Token Bound Accounts) through our Base SDK with express.</li> </ul> <p>For a specific guide about our front-end react SDK, look at our</p> <p>For explanation of our technology, see here. Or have an even deeper look with our whitepaper.</p>"},{"location":"#whats-security-labs-a-little-bit-of-history","title":"What's Security Labs? A little bit of history...","text":"TL;DR for those in a hurry <ol> <li>Security Labs abstracts private key management with a permission-less peer-to-peer network, allowing users to use private keys across several devices and dApps. </li> <li>Solving the private-key management problem (in a non-custodial way) is an unavoidable obstacle to Web3 widespread adoption: An expected, but still non-trivial, infrastructure revolution we are leading. </li> <li>We have over a year of research on distributed secure storage for sensitive data and have developed our own general framework, SCAS (State-change authentication schemes), for authentication methods compatible with our protocol, which include all usual authentication pipelines which don't require users to remember a password or seedphrase (biometrics, hardware-based, behavior-based authentications). </li> <li>Token Bound Accounts (TBAs), which are NFTs which are also smart contract accounts, has allowed us to study wallet-usage pain points further, as well as showing an even bigger need for better private key management, since they present a large and rich set of use cases as \"portable digital profiles\", making losing private keys even a bigger issue for the future of on-chain identity and NFT ecosystems. </li> <li>Security Labs is leader on the TBA market, representing more than 60% of the deployed and used TBAs on Polygon mainnet, with more than 160k TBA wallets.</li> </ol> <p>Security Labs (sLabs) protocol is a permission-less peer-to-peer network for cryptographic tokens (more on our concepts overview), which is a really specific way of saying: We protect and retrieve private keys without having them, by using a decentralized network. This not only allows users to mitigate wallet-loss and theft risk, but also provide a seamless dApp experience across devices and platforms without even knowing what a private key is.</p> <p>A simplified version of how we do it can be summarized as:</p> <p>MPC-based multisig without the burden of finding where store the shards, by storing them distributively on a permission-less and trust-less network whose security scales as it becomes more decentralized, by leveraging unpredictable traffic mixing with ephemeral time-based mix networks with entropy injection.</p> <p>Further details can be explored on our whitepaper, which gives the theoretical foundations of our research to create a general enough authentication framework with decentralization-driven security as a core property; that is one of the results of our first year of research about the topic.</p> <p>Our initial interest in tackling the private key retrieval problem stems from experiencing (a little too much...) the classic and obvious web3 infrastructure problem:</p> <p>Usability (not only onboarding) suffers from complex message signing and high risk to lose your assets if not mindful enough.</p> <p>Both of these problems originate from expecting the user to know \"basic\" key management practices (or accepting a custodial solution...), limiting in the process Web3 ecosystem's capacity to scale to widespread adoption. Even what could be considered basic knowledge on Web3 ecosystems, should not be a requirement for the general audience to know before using a Web3-based product and being burdened by it only shows how Web3 still is in its infancy; albeit not for much longer.</p> <p>Technology infrastructure revolutions have almost always come in the form of improving ease-of-use for some underlying powerful but complex technology by abstracting it to not require specialized expertise (web browsers, DNS servers, cloud storage syncing, etc.). Web3 is not exception. Key management abstraction is a natural cornerstone to achieve usability in dApps, and it MUST be permission-less and trust-less for it to be usable and general enough for any future dApp and still preserve decentralization benefits (autonomy of data, privacy, etc.)</p> <p>To study the impact and market demand for our product, as well as to test hypotheses after our initial research, we embarked into the newest emerging technologies in the space, and found a perfect fit for one of our core objects we have been researching: On-chain identity/personality, through Token Bound Accounts (TBAs).</p> <p>TBAs have deep expressivity capabilities, as briefly discussed on our concepts' page, and additionally, represent on-chain personalities (smart profiles, as we named them) which would be great to link with an intuitive decentralized identity, ideally managed with \"web2-like\" authentication. This is exactly what we do.</p> <p>After entering the TBAs market, we have already captured more than 60% market share on Polygon Mainnet, with more than 160k TBA wallets within just 6 weeks, proving not only the massive interest of the ecosystem around TBAs' capabilities, but also their interest in our project.</p> <p>Today, Security Labs still is innovating and building to lead the infrastructure revolution we all need to make Web3 truly usable, accessible and scalable.</p>"},{"location":"guides/Base_SDK/sdk_node_express/","title":"Backend API Documentation","text":"<p>Brand change</p> <p>Currently, several endpoints and libraries have the name Dippi which is now Security Labs (sLabs), and may be read as such, although libraries and endpoints still need to be called as the former.</p> <p>This document provides technical documentation for the backend API of your application and can go in-depth. In case of looking for a quickstart, look at our SDK + React guide.</p> <p>The backend is developed using Node.js and Express framework, and it comprises various routes that handle different functionalities such as user management, wallet operations, application handling, authentication, and more.</p>"},{"location":"guides/Base_SDK/sdk_node_express/#introduction","title":"Introduction","text":"<p>The backend API plays a pivotal role in the functionality and success of your application. It's designed to seamlessly handle various crucial tasks such as managing users, facilitating wallet operations, handling applications, enabling secure authentication, and more. To streamline these operations and provide enhanced features, your backend leverages the power of the <code>@dippixyz/base</code> library.</p>"},{"location":"guides/Base_SDK/sdk_node_express/#the-power-of-dippixyzbase","title":"The Power of <code>@dippixyz/base</code>","text":"<p>One of the core strengths of this backend lies in its integration with the <code>@dippixyz/base</code> library. This SDK offers a comprehensive set of tools and functionalities that empower your backend to interact seamlessly with the Security Labs (sLabs) platform. By leveraging the capabilities of the <code>@dippixyz/base</code>, your backend gains access to a wealth of features that simplify application management, user authentication, wallet handling, and more.</p> <p>The <code>@dippixyz/base</code> library serves as the bridge between your backend and the sLabs ecosystem. It encapsulates intricate processes, allowing you to focus on building an efficient and feature-rich backend without the need to handle intricate details manually. With the power of the SDK, your backend can execute actions smoothly and securely, offering a seamless experience to your users.</p>"},{"location":"guides/Base_SDK/sdk_node_express/#introduction_1","title":"Introduction","text":"<p>The backend API is responsible for handling various functionalities of your application. It is built using Node.js and Express, providing a set of routes that interact with different models to manage users, wallets, applications, authentication, and more.</p>"},{"location":"guides/Base_SDK/sdk_node_express/#routes","title":"Routes","text":""},{"location":"guides/Base_SDK/sdk_node_express/#application-router","title":"Application Router","text":"<p>The <code>application-router.js</code> handles operations related to application management.</p> <ul> <li><code>GET /dippi/application/list</code>: Retrieve a list of applications.</li> <li><code>POST /dippi/application/create</code>: Create a new application.</li> <li><code>GET /dippi/application/retrieve/:id</code>: Retrieve application details by ID.</li> <li><code>PUT /dippi/application/update/:id</code>: Update application details by ID.</li> </ul>"},{"location":"guides/Base_SDK/sdk_node_express/#application-token-router","title":"Application Token Router","text":"<p>The <code>application-token-router.js</code> manages application tokens.</p> <ul> <li><code>GET /dippi/application-token/retrieve/:id</code>: Retrieve application token details by ID.</li> </ul>"},{"location":"guides/Base_SDK/sdk_node_express/#auth-router","title":"Auth Router","text":"<p>The <code>auth-router.js</code> is responsible for user authentication.</p> <ul> <li><code>POST /dippi/auth/login</code>: User login to the application.</li> </ul>"},{"location":"guides/Base_SDK/sdk_node_express/#user-router","title":"User Router","text":"<p>The <code>user-router.js</code> handles user-related operations.</p> <ul> <li><code>PUT /dippi/user/updateProfile</code>: Update user profile.</li> <li><code>GET /dippi/user/getProfile</code>: Retrieve user profile.</li> </ul>"},{"location":"guides/Base_SDK/sdk_node_express/#wallet-router","title":"Wallet Router","text":"<p>The <code>wallet-router.js</code> manages wallet operations.</p> <ul> <li><code>GET /dippi/wallet/list</code>: Retrieve a list of wallets.</li> <li><code>GET /dippi/wallet/retrieve/:id</code>: Retrieve wallet details by ID.</li> <li><code>PUT /dippi/wallet/update/:id</code>: Update wallet details by ID.</li> <li><code>POST /dippi/wallet/recovery/:id</code>: Recover wallet by ID.</li> <li><code>GET /dippi/wallet/balance/:id</code>: Get wallet balance by ID.</li> <li><code>GET /dippi/wallet/nfts/:id</code>: Get NFTs associated with a wallet by ID.</li> </ul>"},{"location":"guides/Base_SDK/sdk_node_express/#tokenboundaccount-router","title":"TokenBoundAccount Router","text":"<p>The <code>tokenBoundAccount-router.js</code> manages wallet operations.</p> <ul> <li><code>POST /dippi/tokenBoundAccount/create/:data</code>: Recover TBA by ID.</li> </ul>"},{"location":"guides/Base_SDK/sdk_node_express/#models","title":"Models","text":""},{"location":"guides/Base_SDK/sdk_node_express/#dippiclient-model","title":"DippiClient Model","text":"<p>The <code>DippiClient</code> class encapsulates the initialization and configuration of the <code>@dippixyz/base</code> library. This module is essential for establishing a connection between your backend and the Security Labs platform. It provides methods to authenticate, set up authentication tokens, and obtain a configured client instance for further interactions with the Security Labs platform.</p> <p>You can get <code>API KEYS</code> in https://client.dippi.xyz </p>"},{"location":"guides/Base_SDK/sdk_node_express/#constructor","title":"Constructor","text":"<pre><code>constructor()\n</code></pre> <p>The constructor of the <code>DippiClient</code> class is responsible for creating an instance of the Dippi SDK client with the provided configuration parameters.</p> <ul> <li><code>appToken</code>: The Dippi application token obtained from the Dippi platform.</li> <li><code>appId</code>: The Dippi application ID associated with your application.</li> <li><code>url</code>: The URL pointing to the Dippi platform's API : https://api.dippi.xyz</li> </ul>"},{"location":"guides/Base_SDK/sdk_node_express/#example","title":"Example","text":"<pre><code>const Dippi = require('@dippixyz/base');\nrequire('dotenv').config();\n\nclass DippiClient {\n\n    constructor() {\n        this.client = new Dippi({\n            appToken: process.env.APP_TOKEN,\n            appId: process.env.APP_ID,\n            url: process.env.CLIENT_URL,\n        });\n    }\n\n    // ...\n}\n\nmodule.exports = new DippiClient();\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#method-init","title":"Method: init","text":"<pre><code>async init()\n</code></pre> <p>The <code>init</code> method within the <code>DippiClient</code> class handles the authentication process using the Dippi SDK. It performs the login action using the configured client and sets the obtained access token for future API calls.</p> <ul> <li>It returns a configured Dippi SDK client instance ready to interact with the Dippi platform.</li> </ul>"},{"location":"guides/Base_SDK/sdk_node_express/#example_1","title":"Example","text":"<pre><code>async init() {\n    const { accessToken } = await this.client.auth.login();\n    this.client.setAuthToken(accessToken);\n    return this.client;\n}\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#auth-model","title":"Auth Model","text":"<p>The <code>auth.js</code> file defines methods related to user authentication using the Dippi SDK.</p>"},{"location":"guides/Base_SDK/sdk_node_express/#method-login","title":"Method: login","text":"<pre><code>const dippiClient = require('./dippiClient');\n\nconst login = async () =&gt; {\n    const dippi = await dippiClient.init();\n    return await dippi.auth.login();\n}\n\nmodule.exports = {\n    login,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#application-model","title":"Application Model","text":"<p>The <code>application.js</code> file provides methods to interact with the application-related functionalities using the Dippi SDK.</p>"},{"location":"guides/Base_SDK/sdk_node_express/#method-list","title":"Method: list","text":"<pre><code>const dippiClient = require('./dippiClient');\n\nconst list = async () =&gt; {\n    const dippi = await dippiClient.init();\n    return await dippi.application.list();\n}\n\nmodule.exports = {\n    list,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#method-create","title":"Method: create","text":"<pre><code>const dippiClient = require('./dippiClient');\n\nconst create = async (data) =&gt; {\n    const dippi = await dippiClient.init();\n    return await dippi.application.create(data);\n}\n\nmodule.exports = {\n    create,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#method-retrieve","title":"Method: retrieve","text":"<pre><code>const dippiClient = require('./dippiClient');\n\nconst retrieve = async (id) =&gt; {\n    const dippi = await dippiClient.init();\n    return await dippi.application.retrieve(id);\n}\n\nmodule.exports = {\n    retrieve,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#method-update","title":"Method: update","text":"<pre><code>const dippiClient = require('./dippiClient');\n\nconst update = async (id, data) =&gt; {\n    const dippi = await dippiClient.init();\n    return await dippi.application.update(id, data);\n}\n\nmodule.exports = {\n    update,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#application-token-model","title":"Application Token Model","text":"<p>The <code>application-token.js</code> file provides methods to retrieve application token details using the Dippi SDK.</p>"},{"location":"guides/Base_SDK/sdk_node_express/#method-retrieve_1","title":"Method: retrieve","text":"<pre><code>const dippiClient = require('./dippiClient');\n\nconst retrieve = async (id) =&gt; {\n    const dippi = await dippiClient.init();\n    return await dippi.applicationToken.retrieve(id);\n}\n\nmodule.exports = {\n    retrieve,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#user-model","title":"User Model","text":"<p>The <code>user.js</code> file defines methods to interact with user-related operations using the Dippi SDK.</p>"},{"location":"guides/Base_SDK/sdk_node_express/#method-getprofile","title":"Method: getProfile","text":"<pre><code>const dippiClient = require('./dippiClient');\n\nconst getProfile = async () =&gt; {\n    const dippi = await dippiClient.init();\n    return await dippi.user.getProfile();\n}\n\nmodule.exports = {\n    getProfile,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#method-updateprofile","title":"Method: updateProfile","text":"<pre><code>const dippiClient = require('./dippiClient');\n\nconst updateProfile = async (data) =&gt; {\n    const dippi = await dippiClient.init();\n    return await dippi.user.updateProfile(data);\n}\n\nmodule.exports = {\n    updateProfile,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#wallet-model","title":"Wallet Model","text":"<p>The <code>wallet.js</code> file provides methods to interact with wallet-related operations using the Dippi SDK.</p>"},{"location":"guides/Base_SDK/sdk_node_express/#method-list_1","title":"Method: list","text":"<pre><code>const dippiClient = require('./dippiClient');\n\nconst list = async () =&gt; {\n    const dippi = await dippiClient.init();\n    return await dippi.wallet.list();\n}\n\nmodule.exports = {\n    list,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#method-retrieve_2","title":"Method: retrieve","text":"<pre><code>const dippiClient = require('./dippiClient');\n\nconst retrieve = async (id) =&gt; {\n    const dippi = await dippiClient.init();\n    return await dippi.wallet.retrieve(id);\n}\n\nmodule.exports = {\n    retrieve,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#method-update_1","title":"Method: update","text":"<pre><code>const dippiClient = require('./dippiClient');\n\nconst update = async (id, data) =&gt; {\n    const dippi = await dippiClient.init();\n    return await dippi.wallet.update(id, data);\n}\n\nmodule.exports = {\n    update,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#method-recovery","title":"Method: recovery","text":"<pre><code>const dippiClient = require('./dippiClient');\n\nconst recovery = async (id, data) =&gt; {\n    const dippi = await dippiClient.init();\n    return await dippi.wallet.recovery(id, data);\n}\n\nmodule.exports = {\n    recovery,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#method-balance","title":"Method: balance","text":"<pre><code>const dippiClient = require('./dippiClient');\n\nconst balance = async (id) =&gt; {\n    const dippi = await dippiClient.init();\n    return await dippi.wallet.balance(id);\n}\n\nmodule.exports = {\n    balance,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#method-nfts","title":"Method: nfts","text":"<pre><code>const dippiClient = require('./dippiClient');\n\nconst nfts = async (\n\nid) =&gt; {\n    const dippi = await dippiClient.init();\n    return await dippi.wallet.nfts(id);\n}\n\nmodule.exports = {\n    nfts,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_node_express/#tokenboundaccount-model","title":"tokenBoundAccount Model","text":"<p>The <code>tokenBoundAccount.js</code> file provides methods to interact with tokenBoundAccount-related operations using the Dippi SDK.</p>"},{"location":"guides/Base_SDK/sdk_node_express/#method-create_1","title":"Method: create","text":"<pre><code>const TBA = require('@dippixyz/base');\n\nconst create = async (data) =&gt; {\n    const TBAClient = new TBA(paramsOauthSession);\n    TBAClient.init(tbaCreateOptions)\n    return await TBAClient.create();\n}\n\nmodule.exports = {\n    create,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_react/","title":"SDK + React: Quickstart guide","text":"<p>Brand change</p> <p>Currently, several endpoints and libraries have the name Dippi which is now Security Labs (sLabs), and may be read as such, although libraries and endpoints still need to be called as the former.</p> <p>Welcome to your guide to using <code>@dippixyz/base</code> consumed directly through ReactJS components. For our suite of plug-and-play front-end components see our guide for <code>@dippixyz/react-sdk</code> here \ud83d\ude80. Please contact us if you face any problems implementing!</p> <p>Please note the following frequent issues before you begin:</p> <ol> <li>This SDK is written for JS \u2014 you\u2019ll need to run this on Node version \u2265 18. This SDK uses fetch as a request manager.</li> <li>The <code>@dippixyz/base</code> SDK can be used both in your backend or your frontend!</li> <li>Need to keep users in the main site while they sign-up/sign-in? We understand! To enable this for your site and your users we recommend you use the iFrame code provided ahead. Keep in mind you can always choose how to display our site.</li> <li>We have developed a suite of components that are included in <code>@dippixyz/react-sdk</code> to help you set up your web3 enabled website: sign up, login, reset password, change password, and signing and sending token transactions (More functionalities coming soon!). The components in <code>@dippixyz/react-sdk</code> are only usable on the frontend.</li> </ol>"},{"location":"guides/Base_SDK/sdk_react/#step-1-getting-your-api-token-and-application-id","title":"Step 1: Getting your API token and Application ID","text":"<p>Go to our site: client.dippi.xyz. Once there you must create a project. That project will be loaded with all the necessary configurations to be used as rules when creating wallets for your users.</p> <p></p> <p>You\u2019ll find the following form next:</p> <p></p> <p>Here\u2019s what you need to know about each of the fields:</p> <ol> <li>App name: Choose any name to identify the application you are registering.</li> <li>Environments: Decide if the user wallets will be generated in test net or main net.</li> <li>Assigned to: Define the desired chain in which the wallet will be created.</li> <li>Authentication Type: Define the type of authentication that will be shown to your users when they signup/sign in with Dippi. They\u2019ll have two options:</li> <li>Email: the user will receive a confirmation email</li> <li>SMS : the user will receive a OTP via SMS to confirm their account.</li> <li>Generate API Token : This will automatically generate an API Token for your app. You\u2019ll use this API Token in the SDK as the requested credentials.</li> </ol> <p>Example:</p> <p></p> <p>\u26a0\ufe0f IMPORTANT: Once your project is created you\u2019ll obtain an API Token and Application ID: make sure to store these safely \u2014back them up and don\u2019t lose them!</p> <p>Note: The <code>API Token</code> can\u2019t be recovered if lost. If you ever lose this, you\u2019ll need to generate a new one. To create a new Token follow this guide: {{link}}</p>"},{"location":"guides/Base_SDK/sdk_react/#step-2-installation-and-the-button-component","title":"Step 2: Installation and the button component","text":"<p>Once your <code>API Token</code> and <code>Application ID</code> are ready you can start using our SDK.</p> <p>The example provided below assumes that you are using <code>React + Typescript</code> as a framework for your frontend. As mentioned earlier the methods provided by the SDK can also be used in your backend.</p> <ol> <li>Install the SDK. If you want to view the package in npm, click below:</li> </ol> <p>npm: @dippixyz/base</p> <p>Open your project\u2019s terminal and run this command:</p> <pre><code>npm i @dippixyz/base\n</code></pre> <ol> <li>Once the SDK is installed you can import it this way:</li> </ol> <pre><code>const Dippi = require(\"@dippixyz/base\");\n</code></pre> <ol> <li> <p>We recommend creating an environment variable in your project (<code>.env</code>) or a separate file where you can store your credentials without exposing them in your code.</p> <p>Assuming you have created a new .env file, you should get the following parameters:</p> <pre><code>DIPPI_API_TOKEN = &lt;*YOUR_API_TOKEN*&gt;\nDIPPI_APPLICATION_ID = &lt;*YOUR_APPLICATION_ID*&gt;\nDIPPI_URL = https://api.dippi.xyz\n</code></pre> </li> </ol> <p>The <code>DIPPI_URL</code> parameter should always be the one in the example above.</p> <ol> <li>Next we\u2019ll create a new component which will contain the \u2018Sign-in with Dippi\u2019 button.</li> </ol> <p>Example: create a new file in your components folder\u2014</p> <p><code>/components/dippi.tsx</code></p> <pre><code>import React, { useState } from \"react\";\nconst Dippi = require(\"@dippixyz/base\");\n\nfunction DippiSignin() {\n  return (\n    &lt;div&gt;\n      &lt;button\n        style={{\n          backgroundColor: \"white\",\n          borderRadius: 5,\n          borderColor: \"white\",\n          margin: 4,\n          padding: \"5px 20px 5px 20px\",\n          border: 1,\n          boxShadow: \"1px 2px 4px grey\",\n        }}\n      &gt;\n        &lt;img\n          src=\"https://client.dippi.xyz/assets/img/logo.png\"\n          alt=\"Dippi Icon\"\n          style={{ width: 30, marginRight: 4 }}\n        /&gt;\n        &lt;span&gt;\n          &lt;strong&gt;Continue with Dippi&lt;/strong&gt;\n        &lt;/span&gt;\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default DippiSignin;\n</code></pre> <p>Hooray! Your button should look like this:</p> <p></p> <p>Bear in mind that this is just the basic component. You can build it up and enhance it with what you learn throughout this tutorial.</p> <ol> <li> <p>Once the SDK is imported you can create the <code>DippiClient</code> with the following settings:</p> <pre><code>const DippiClient = new Dippi({\n  appToken: process.env.DIPPI_API_TOKEN,\n  appId: process.env.DIPPI_APPLICATION_ID,\n  url: process.env.DIPPI_URL,\n  urlReturn: \"http://localhost:3002/dippi\",\n});\n</code></pre> <p>The <code>urlReturn</code> parameter is the URL of your project where the DippiClient will return the responses to your requests.</p> </li> <li> <p>Create an asynchronous function called <code>initClientDippi()</code> that will be used to initialize the <code>DippiClient</code>:</p> </li> </ol> <pre><code>const initClientDippi = async () =&gt; {\n  const { accessToken } = await DippiClient.auth.login();\n  DippiClient.setAuthToken(accessToken);\n};\n</code></pre> <ul> <li> <p>The <code>login()</code> function returns an object containing an <code>accessToken</code> that is assigned to the <code>accessToken</code> variable. This is achieved by de-structuring the returned object.</p> </li> <li> <p>Next, <code>DippiClient.setAuthToken(accessToken)</code> is used to set the access token on the Dippi client. This will allow the client to perform authenticated operations later on.</p> </li> <li> <p>Declare a function called <code>openIframeDippi()</code> which will set parameters of the iFrame displayed to the user \u2014such as size, margins, and other options:</p> </li> </ul> <pre><code>const openIframeDippi = async () =&gt; {\n  await initClientDippi();\n  const { url } = await DippiClient.auth.getUrl();\n  const left = (window.innerWidth - 500) / 2;\n  const top = (window.innerHeight - 650) / 2;\n  const options = `toolbar=0,scrollbars=1,status=1,resizable=1,location=1,menuBar=0,width=500,height=650,top=${top},left=${left}`;\n  window.open(url, \"childWindow\", options);\n  localStorage.removeItem(\"registration_complete\");\n};\n</code></pre> <p>Note that <code>initClientDippi()</code> is implicit in this method and it will initialize the <code>DippiClient</code>. You will then obtain the URL to be displayed in the iFrame through the <code>getUrl()</code> method.</p> <ol> <li>Let\u2019s add the <code>openIframeDippi()</code> to the button in the previously created component. This will be executed with the onClick event.</li> </ol> <pre><code>&lt;button\n  onClick={openIframeDippi}\n  style={{\n    backgroundColor: \"white\",\n    borderRadius: 5,\n    borderColor: \"white\",\n    margin: 4,\n    padding: \"5px 20px 5px 20px\",\n    border: 1,\n    boxShadow: \"1px 2px 4px grey\",\n  }}\n&gt;\n  &lt;img\n    src=\"https://client.dippi.xyz/assets/img/logo.png\"\n    alt=\"Dippi Icon\"\n    style={{ width: 30, marginRight: 4 }}\n  /&gt;\n  &lt;span&gt;\n    &lt;strong&gt;Continue with Dippi&lt;/strong&gt;\n  &lt;/span&gt;\n&lt;/button&gt;\n</code></pre> <p>Great work! Let\u2019s test the button and check for the modal. It should look like this:</p> <p></p> <p>From this point forward everything becomes user experience: your site/app is ready to onboard and log in users through Dippi \ud83d\ude4c</p> <p>\u26a0\ufe0f IMPORTANT: The credentials used in this modal are NOT the ones you used when registering on client.dippi.xyz to create your project. Again: these are credentials created by the user to be interact with your site.</p> <p>Please refer to the users\u2019 side of the process in this guide: {{A user\u2019s guide to Dippi}}</p>"},{"location":"guides/Base_SDK/sdk_react/#step-3-managing-components-response","title":"Step 3: Managing Component's response","text":"<p>Now that the component is ready, you\u2019ll manage the response obtained from Dippi once the user is done with the process:</p> <ol> <li>Are you using the code we provided earlier to set up an iFrame or floating window? Then you must define a <code>window.addEventListener</code> which will expect the <code>window.opener.postMessage</code> message sent by Dippi</li> </ol> <pre><code>window.addEventListener(\"message\", async (event) =&gt; {\n  const registration_complete = localStorage.getItem(\n    \"registration_complete\"\n  );\n  const legit_registration_event_completed =\n    event.data.type == \"registration_complete\" &amp;&amp;\n    !registration_complete &amp;&amp;\n    event.origin == \"https://client.dippi.xyz\"; // (1)\n\n  if (legit_registration_event_completed) {\n    // Verify that the origin of the event is from our official site.\n    localStorage.setItem(\"registration_complete\", \"true\");\n\n    const { redirectUrl, userId, walletAddress } = event.data;\n  }\n});\n</code></pre> <ol> <li> This verifies that the origin of the event is from our official site.</li> </ol> <p>In <code>event.data</code> you should expect an object like this:</p> <pre><code>{\n  redirectUrl: \"http://localhost:3002/dippi/success/0x7A61081Afd7354385CbE97c718djnflasb2Bd/cljrqklo0983nrp1bf9zzr1j5\";\n  type: \"registration_complete\";\n  userId: \"cljrqklo0983nrp1bf9zzr1j5\";\n  walletAddress: \"0x7A61081Afd7354385CbE97c718djnflasb2Bd\";\n}\n</code></pre> <p>\u26a0\ufe0f IMPORTANT: If you are not using the iFrame (instead obtaining a URL through the <code>DippiClient.auth.getUrl()</code> method) and get directed to our site, the action you will receive in response will be a redirection to a URL with the following structure:</p> <p><code>${returnUrl}/success/${wallet.address}/${userId}</code></p> <p>Where <code>returnUrl</code> is the established parameter in the <code>DippiClient</code>, followed by <code>/success</code> \u2014indicating that everything worked to spec: <code>wallet.address</code> will be the address for the generated wallet, and <code>userId</code> the registered user identifier.</p> <p>Here\u2019s how something like that would look like:</p> <pre><code>http://localhost:3002/dippi/success/0xa0c903C2756e7ceA093246346C249194701d7805/cljrp5uh30005rp1b3wifc4wr\n</code></pre> <p>If an error occurs and you want to handle it, the URL will have the following structure:</p> <p><code>*${returnUrl}/error/${error}*</code></p> <p>Ready? Extract the second parameter in this case and proceed.</p> <ol> <li>You can now obtain the complete user information to register it in your database and assume that their session has been initiated. To do this, define a new asynchronous method called <code>getUser()</code> which will obtain the users\u2019 information:</li> </ol> <pre><code>const getUser = async (userId: string) =&gt; {\n  await initClientDippi();\n  const user = await DippiClient.user.getProfile(userId);\n  console.log(\"user :::: &gt;&gt;&gt;\", user);\n};\n</code></pre> <p>In the <code>window.addEventListener</code> one must add the call for the <code>getUser()</code> function after the <code>const { redirectUrl, userId, walletAddress } = event.data;</code> line.</p> <p>The complete method would look like this:</p> <pre><code>window.addEventListener(\"message\", async (event) =&gt; {\n  const registration_complete = localStorage.getItem(\n    \"registration_complete\"\n  );\n\n  if (\n    event.data.type == \"registration_complete\" &amp;&amp;\n    !registration_complete &amp;&amp;\n    event.origin == \"https://client.dippi.xyz\"\n  ) {\n    // Verify that the origin of the event is from our official site.\n    // Save in local storage registration_complete = true\n    localStorage.setItem(\"registration_complete\", \"true\");\n\n    const { redirectUrl, userId, walletAddress } = event.data;\n    await getUser(userId); // Add getUser function\n  }\n});\n</code></pre> <p>The <code>await DippiClient.user.getProfile(userId)</code> method returns a response like this:</p> <pre><code>{\n  applicationId: \"clj68i4fs0001qx1bxyb7abks\";\n  createdAt: \"2023-07-06T17:30:00.277Z\";\n  email: \"victor@dippi.xyz\";\n  id: \"cljrfawno0009rp1bznxl8k2h\";\n  isActive: true;\n  isVerified: true;\n  lastLogin: null;\n  name: \"victor+kjnasdlk2\";\n  password: \"$argon2id$v=19$m=65536,t=3,p=4$Q3Nrs3SWfCIYoLOnj6fY3Q$or1LYlbWgf3uDfWW+7WrKP9r5D4/43U28eVWhQvS35w\";\n  phone: \"\";\n  refreshToken: null;\n  updatedAt: \"2023-07-06T17:30:21.794Z\";\n}\n</code></pre> <p>Once this information is received, you can use it as necessary in your application to start the users\u2019 session.</p> <ol> <li>The final component would look like this:</li> </ol> <pre><code>import React, { useState } from \"react\";\nconst Dippi = require(\"@dippixyz/base\");\n\nfunction DippiSignin() {\n  const DippiClient = new Dippi({\n    appToken: process.env.DIPPI_API_TOKEN,\n    appId: process.env.DIPPI_APPLICATION_ID,\n    url: process.env.DIPPI_URL,\n    urlReturn: \"http://localhost:3002/dippi\",\n  });\n\n  const initClientDippi = async () =&gt; {\n    const { accessToken } = await DippiClient.auth.login();\n    DippiClient.setAuthToken(accessToken);\n  };\n\n  const openIframeDippi = async () =&gt; {\n    await initClientDippi();\n    const { url } = await DippiClient.auth.getUrl();\n    const left = (window.innerWidth - 500) / 2;\n    const top = (window.innerHeight - 650) / 2;\n    const options = `toolbar=0,scrollbars=1,status=1,resizable=1,location=1,menuBar=0,width=500,height=650,top=${top},left=${left}`;\n    window.open(url, \"childWindow\", options);\n    localStorage.removeItem(\"registration_complete\");\n  };\n\n  window.addEventListener(\"message\", async (event) =&gt; {\n    const registration_complete = localStorage.getItem(\"registration_complete\");\n\n    if (\n      event.data.type == \"registration_complete\" &amp;&amp;\n      !registration_complete &amp;&amp;\n      event.origin == \"https://client.dippi.xyz\"\n    ) {\n      // Verify that the origin of the event is from our official site.\n      // Save in local storage registration_complete = true\n      localStorage.setItem(\"registration_complete\", \"true\");\n\n      const { redirectUrl, userId, walletAddress } = event.data;\n      await getUser(userId);\n    }\n  });\n\n  const getUser = async (userId: string) =&gt; {\n    await initClientDippi();\n    const user = await DippiClient.user.getProfile(userId);\n    console.log(\"user :::: &gt;&gt;&gt;\", user);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;button\n        style={{\n          backgroundColor: \"white\",\n          borderRadius: 5,\n          borderColor: \"white\",\n          margin: 4,\n          padding: \"5px 20px 5px 20px\",\n          border: 1,\n          boxShadow: \"1px 2px 4px grey\",\n        }}\n        onClick={openIframeDippi}\n      &gt;\n        &lt;img\n          src=\"https://client.dippi.xyz/assets/img/logo.png\"\n          alt=\"Dippi Icon\"\n          style={{ width: 30, marginRight: 4 }}\n        /&gt;\n        &lt;span&gt;\n          &lt;strong&gt;Continue with Dippi&lt;/strong&gt;\n        &lt;/span&gt;\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default DippiSignin;\n</code></pre>"},{"location":"guides/Base_SDK/sdk_reactNative_expo/","title":"SDK + React Native + Expo","text":""},{"location":"guides/Base_SDK/sdk_reactNative_expo/#introduction","title":"Introduction","text":"<p>Brand change</p> <p>Currently, several endpoints and libraries have the name Dippi which is now Security Labs (sLabs), and may be read as such, although libraries and endpoints still need to be called as the former.</p> <p>This document aims to explain the provided React Native code that implements Dippi sign-in functionality for mobile applications. The code utilizes various libraries and APIs, including React Native, Expo, and the Dippi SDK, to enable users to sign in using their Dippi accounts.</p>"},{"location":"guides/Base_SDK/sdk_reactNative_expo/#code-overview","title":"Code Overview","text":""},{"location":"guides/Base_SDK/sdk_reactNative_expo/#imports","title":"Imports","text":"<pre><code>import React, { useState } from 'react';\nimport { TouchableOpacity, Text, Button, View, Image, StyleSheet } from 'react-native';\nimport * as WebBrowser from 'expo-web-browser';\nimport * as Linking from 'expo-linking';\n</code></pre> <p>The code begins with importing the required modules and libraries:</p> <ul> <li><code>React</code> and <code>useState</code> from React: Used for creating functional components and managing component state.</li> <li><code>TouchableOpacity</code>, <code>Text</code>, <code>Button</code>, <code>View</code>, <code>Image</code>, and <code>StyleSheet</code> from <code>react-native</code>: UI components and styles for building the user interface.</li> <li><code>WebBrowser</code> and <code>Linking</code> from <code>expo</code>: Libraries for opening web browser sessions and handling URLs.</li> </ul>"},{"location":"guides/Base_SDK/sdk_reactNative_expo/#dippi-sdk-initialization","title":"Dippi SDK Initialization","text":"<pre><code>const Dippi = require('@dippixyz/base');\n\nfunction DippiSignin() {\n    const DippiClient = new Dippi({\n        appToken: '...',  // Dippi app token\n        appId: '...',     // Dippi app ID\n        url: '...',       // Dippi API base URL\n        urlReturn: Linking.createURL(\"\")  // Return URL after authentication\n    });\n}\n</code></pre> <ul> <li>The Dippi SDK is imported and initialized with necessary parameters: <code>appToken</code>, <code>appId</code>, <code>url</code>, and <code>urlReturn</code>.</li> <li><code>appToken</code>: Authentication token for the Dippi application.</li> <li><code>appId</code>: Identifier for the Dippi application.</li> <li><code>url</code>: Base URL for the Dippi API.</li> <li><code>urlReturn</code>: The URL where the user will be redirected after authentication.</li> </ul>"},{"location":"guides/Base_SDK/sdk_reactNative_expo/#dippi-sdk-initialization-function","title":"Dippi SDK Initialization Function","text":"<pre><code>initClientDippi = async () =&gt; {\n    const { accessToken } = await DippiClient.auth.login();\n    DippiClient.setAuthToken(accessToken);\n    const { url } = await DippiClient.auth.getUrl();\n    return url;\n};\n</code></pre> <ul> <li><code>initClientDippi</code>: An asynchronous function that initiates the Dippi SDK client.</li> <li>The function performs the following steps:<ol> <li>Calls the <code>login</code> method of the Dippi authentication module to get an access token.</li> <li>Sets the obtained access token using the <code>setAuthToken</code> method of the Dippi client.</li> <li>Calls the <code>getUrl</code> method of the Dippi authentication module to obtain an authentication URL.</li> <li>Returns the authentication URL.</li> </ol> </li> </ul>"},{"location":"guides/Base_SDK/sdk_reactNative_expo/#state-management","title":"State Management","text":"<pre><code>const [result, setResult] = useState(null);\n</code></pre> <ul> <li>A component state variable <code>result</code> is initialized using the <code>useState</code> hook.</li> </ul>"},{"location":"guides/Base_SDK/sdk_reactNative_expo/#authentication-session-function","title":"Authentication Session Function","text":"<pre><code>_openAuthSessionAsync = async () =&gt; {\n    const url = await initClientDippi();\n\n    try {\n        let result = await WebBrowser.openAuthSessionAsync(\n            url,\n        );\n        const walletAddress = result.url.split('/')[4];\n        const userId = result.url.split('/')[5];\n\n        const user = await DippiClient.user.getProfile(userId);\n        setResult(user);\n    } catch (error) {\n        console.log(error);\n    }\n};\n</code></pre> <ul> <li><code>_openAuthSessionAsync</code>: An asynchronous function that initiates the authentication session.</li> <li>The function does the following:<ol> <li>Calls the <code>initClientDippi</code> function to get the authentication URL.</li> <li>Uses <code>WebBrowser.openAuthSessionAsync</code> to open a browser session with the authentication URL.</li> <li>Parses the returned URL to extract <code>walletAddress</code> and <code>userId</code>.</li> <li>Calls <code>DippiClient.user.getProfile</code> with the extracted <code>userId</code> to retrieve the user's profile.</li> <li>Sets the retrieved user profile in the component state using <code>setResult</code>.</li> </ol> </li> </ul>"},{"location":"guides/Base_SDK/sdk_reactNative_expo/#component-rendering","title":"Component Rendering","text":"<pre><code>return (\n    &lt;&gt;\n        &lt;View&gt;\n            &lt;Text&gt;Redirect Example&lt;/Text&gt;\n            &lt;Button\n                onPress={this._openAuthSessionAsync}\n                title=\"Continue with Dippi\"\n            /&gt;\n            &lt;Text&gt;Result: {JSON.stringify(result)}&lt;/Text&gt;\n        &lt;/View&gt;\n    &lt;/&gt;\n);\n</code></pre> <ul> <li>The <code>DippiSignin</code> component's rendering logic.</li> <li>Renders a <code>View</code> container with the following components:<ul> <li>A <code>Text</code> component displaying \"Redirect Example\".</li> <li>A <code>Button</code> component with the text \"Continue with Dippi\", which triggers the <code>_openAuthSessionAsync</code> function when pressed.</li> <li>A <code>Text</code> component displaying the result as a JSON stringified version of the <code>result</code> state variable.</li> </ul> </li> </ul>"},{"location":"guides/Base_SDK/sdk_reactNative_expo/#conclusion","title":"Conclusion","text":"<p>The provided React Native code demonstrates how to integrate Dippi sign-in functionality into a mobile application. It uses the Dippi SDK to authenticate users, open an authentication session in a web browser, and retrieve user information after successful authentication. This code can serve as a foundation for building a Dippi sign-in feature in a React Native mobile app.</p>"},{"location":"guides/Base_SDK/sdk_tba_express/","title":"Backend API Documentation","text":"<p>Brand change</p> <p>Currently, several endpoints and libraries have the name Dippi which is now Security Labs (sLabs), and may be read as such, although libraries and endpoints still need to be called as the former.</p> <p>This document provides technical documentation for the backend API of your application and can go in-depth. In case of looking for a quickstart, look at our SDK + React guide.</p> <p>The backend is developed using Node.js and Express framework, and it comprises various routes that handle different functionalities such as user management, wallet operations, application handling, authentication, and more.</p>"},{"location":"guides/Base_SDK/sdk_tba_express/#introduction","title":"Introduction","text":"<p>The backend API plays a pivotal role in the functionality and success of your application. It's designed to seamlessly handle various crucial tasks such as managing users, facilitating wallet operations, handling applications, enabling secure authentication, and more. To streamline these operations and provide enhanced features, your backend leverages the power of the <code>@dippixyz/base</code> library.</p>"},{"location":"guides/Base_SDK/sdk_tba_express/#the-power-of-dippixyzbase","title":"The Power of <code>@dippixyz/base</code>","text":"<p>One of the core strengths of this backend lies in its integration with the <code>@dippixyz/base</code> library. This SDK offers a comprehensive set of tools and functionalities that empower your backend to interact seamlessly with the Dippi platform. By leveraging the capabilities of the <code>@dippixyz/base</code>, your backend gains access to a wealth of features that simplify application management, user authentication, wallet handling, and more.</p> <p>The <code>@dippixyz/base</code> library serves as the bridge between your backend and the Dippi ecosystem. It encapsulates intricate processes, allowing you to focus on building an efficient and feature-rich backend without the need to handle intricate details manually. With the power of the SDK, your backend can execute actions smoothly and securely, offering a seamless experience to your users.</p>"},{"location":"guides/Base_SDK/sdk_tba_express/#introduction_1","title":"Introduction","text":"<p>The backend API is responsible for handling various functionalities of your application. It is built using Node.js and Express, providing a set of routes that interact with different models to manage users, wallets, applications, authentication, and more.</p>"},{"location":"guides/Base_SDK/sdk_tba_express/#routes","title":"Routes","text":""},{"location":"guides/Base_SDK/sdk_tba_express/#tokenaccountfunc-router","title":"TokenAccountFunc Router","text":"<p>The <code>tokenBoundAccount-router.js</code> manages wallet operations.</p> <ul> <li><code>POST /dippi/tokenBoundAccount/create</code>: Create 6551.</li> </ul>"},{"location":"guides/Base_SDK/sdk_tba_express/#models","title":"Models","text":""},{"location":"guides/Base_SDK/sdk_tba_express/#tokenboundaccount-model","title":"tokenBoundAccount Model","text":"<p>The <code>tokenBoundAccount.js</code> file provides methods to interact with tokenBoundAccount-related operations using the Dippi SDK.</p>"},{"location":"guides/Base_SDK/sdk_tba_express/#method-create","title":"Method: create","text":"<pre><code>const TBA = require('@dippixyz/base');\n\nconst create = async (data) =&gt; {\n    const TBAClient = new TBA(paramsOauthSession);\n    TBAClient.init(tbaCreateOptions)\n    return await TBAClient.create();\n}\n\nmodule.exports = {\n    create,\n};\n</code></pre>"},{"location":"guides/Base_SDK/sdk_tba_express/#tba-quickstart-guide","title":"TBA: Quickstart guide","text":""},{"location":"guides/Base_SDK/sdk_tba_express/#step-1-getting-your-api-token-and-application-id","title":"Step 1: Getting your API token and Application ID","text":"<p>Go to our site: client.dippi.xyz. Once there you must create a project. That project will be loaded with all the necessary configurations to be used as rules when creating wallets for your users.</p> <p></p> <p>You\u2019ll find the following form next:</p> <p></p> <p>Here\u2019s what you need to know about each of the fields:</p> <ol> <li>App name: Choose any name to identify the application you are registering.</li> <li>Environments: Decide if the user wallets will be generated in test net or main net.</li> <li>Assigned to:  Define the desired chain in which the w</li> <li>Authentication Type: Define the type of authentication that will be shown to your users when they signup/sign in with Dippi. They\u2019ll have two options:<ol> <li>Email: the user will receive a confirmation email</li> <li>SMS : the user will receive a OTP via SMS to confirm their account.</li> </ol> </li> <li>Generate API Token : This will automatically generate an API Token for your app. You\u2019ll use this API Token in the SDK as the requested credentials.</li> </ol> <p>Example:</p> <p></p> <p>\u26a0\ufe0f IMPORTANT: Once your project is created you\u2019ll obtain an API Token and Application ID: make sure to store these safely \u2014back them up and don\u2019t lose them!</p> <p>Note: The <code>API Token</code>  can\u2019t be recovered if lost. If you ever lose this, you\u2019ll need to generate a new one. To create a new Token follow this guide: {{link}}</p>"},{"location":"guides/Base_SDK/sdk_tba_express/#step-2-installation-and-the-button-component","title":"Step 2: Installation and the button component","text":"<p>Once your <code>API Token</code> and <code>Application ID</code> are ready you can start using our SDK.</p> <p>The example provided below assumes that you are using <code>React + Typescript</code> as a framework for your frontend. As mentioned earlier the methods provided by the SDK can also be used in your backend.</p> <ol> <li> <p>Install the SDK. If you want to view the package in npm, click below: </p> <p>npm: @dippixyz/base</p> <p>Open your project\u2019s terminal and run this command: </p> <pre><code>npm i @dippixyz/base\n</code></pre> <ol> <li>Once the SDK is installed you can import it this way:</li> </ol> <pre><code>const TBA = require('@dippixyz/base');\n</code></pre> <ol> <li> <p>We recommend creating an environment variable in your project (<code>.env</code>) or a separate file where you can store your credentials without exposing them in your code.</p> <p>Assuming you have created a new .env file, you should get the following parameters:</p> <p><pre><code>DIPPI_API_TOKEN = &lt;*YOUR_API_TOKEN*&gt;\nDIPPI_APPLICATION_ID = &lt;*YOUR_APPLICATION_ID*&gt;\nDIPPI_URL = https://api.dippi.xyz \n</code></pre> The <code>DIPPI_URL</code> parameter should always be the one in the example above.</p> </li> </ol> </li> <li> <p>The following is your index file. Add the call to the TBA SDK function in order to consume the services:      <pre><code>const app = express();\nconst TBA = require('@dippixyz/base');\n\n\napp.get('/test', async (req, res) =&gt; {\n    //Authentication parameters, previously obtained in step 1, on the DIPPI platform.\n    const TBAClient = new TBA({\n        appToken: APP_TOKEN,\n        appId: APP_ID,\n        url: CLIENT_URL,\n    });\n\n    //If you do not specify the parameters destinationWallet and NFTid, DIPPI will generate the values.\n    const tbaCreateOptions = {\n        nftContract: &lt;destinationWallet&gt;,\n        destinationWallet:&lt;NFTdropContract&gt;,\n        nftId: &lt;NFTid&gt;\n    } \n\n    TBAClient.init(tbaCreateOptions)\n\n    try {\n        let tbaObj = await TBAClient.create()\n        res.send({'tbaObj': tbaObj})\n    } catch (error) {\n        res.send({'error validation': error})\n    }\n}\n</code></pre>     A test method is defined with the route \"test\". Keep in mind that its nature will be asynchronous. In this case, the response will be resolved using an await, and you can also apply a then to the promise.</p> </li> </ol>"},{"location":"guides/Frontend_SDKs/frontend_react/","title":"SDK + React: Quickstart guide","text":"<p>Brand change</p> <p>Currently, several endpoints and libraries have the name Dippi which is now Security Labs (sLabs), and may be read as such, although libraries and endpoints still need to be called as the former.</p>"},{"location":"guides/Frontend_SDKs/frontend_react/#step-1-get-your-api-token-and-application-id-as-mentioned-previously","title":"Step 1: Get your API token and Application ID as mentioned previously","text":""},{"location":"guides/Frontend_SDKs/frontend_react/#step-2-create-a-simple-react-app","title":"Step 2: Create a simple React app","text":"<p>Note</p> <p>This tutorial was made using Vite v5.0.12, so if the flow for creating your project is different from the instructions you find in this tutorial you can do <code>npm create vite@5.0.12</code> instead.</p> <ol> <li>Create a simple React app using your favorite React app creation command, for the sake of this example we're using vite. So go to your terminal and run   <pre><code>npm create vite@latest\n</code></pre></li> <li>Type your project_name. We're using <code>dippi-react</code> as our project name. </li> <li>Select React as your framework. </li> <li>Select TypeScript + SWC as your variant. </li> <li>Go into the <code>dippi-react</code> folder and run <code>npm install</code>. <pre><code>cd dippi-react; npm install\n</code></pre></li> <li>Install our frontend SDK <code>@dippixyz/react-sdk</code> <pre><code>npm install @dippixyz/react-sdk\n</code></pre></li> </ol>"},{"location":"guides/Frontend_SDKs/frontend_react/#step-3-implement-the-dippi-component","title":"Step 3: Implement the Dippi component","text":"<ol> <li>Go to <code>src/main.tsx</code> and import the <code>@dippixyz/react-sdk</code> <code>DippiProvider</code>. This is used to handle communication with the Dippi Backend infrastructure.   <pre><code>import { DippiProvider } from \"@dippixyz/react-sdk\";\n</code></pre></li> <li>Once you've imported the <code>DippiProvider</code> you have to initialize it using the <code>API Token</code> and <code>Application Id</code> that you got during Step 1. We will do this by declaring a constant named <code>DippiConfig</code> and replacing the <code>API Token</code> and <code>Application Id</code> values.   <pre><code>const dippiConfig = {\n  appToken: [API Token],\n  appId: [Application Id]\n  url: 'https://api.dippi.xyz'\n};\n</code></pre>   Then we will proceed to add the DippiProvider component as a wrapper that will help keep your entire application secured and the <code>Dippi Context</code> data available at all times to perform operations using our suite of components. This is how your <code>src/main.tsx</code> should look once you've added the <code>DippiProvider</code> with its corresponding <code>dippiConfig</code> prop.   <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App.tsx';\nimport './index.css';\nimport { DippiProvider} from '@dippixyz/react-sdk';\n\nconst dippiConfig = {\n  appToken: [API Token], // remember to replace with API Token value\n  appId: [Application Id] // remember to replace with Application Id value\n  url: 'https://api.dippi.xyz'\n};\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  &lt;React.StrictMode&gt;\n    &lt;DippiProvider config={dippiConfig}&gt;\n      &lt;App /&gt;\n    &lt;DippiProvider /&gt;\n  &lt;/React.StrictMode&gt;,\n)\n</code></pre>   Now you're ready to start implementing our suite of frontend components! 9. Next, we're going to set up our login and sign up functionality. Go to <code>src/App.tsx</code> and import the <code>ButtonSignin</code> component and the CSS styles from <code>@dippixyz/react-sdk</code> <pre><code>import { ButtonSignIn } from \"@dippixyz/react-sdk\";\nimport \"@dippixyz/react-sdk/index.css\";\n</code></pre></li> <li>Now replace the code on lines 9 - 34 with the following:   <pre><code>return (\n  &lt;&gt;\n    &lt;div className=\"card\"&gt;\n      &lt;ButtonSignIn /&gt;\n    &lt;/div&gt;\n  &lt;/&gt;\n);\n</code></pre>   Your <code>src/App.tsx</code> should look like this now:   <pre><code>import { useState } from \"react\";\nimport reactLogo from \"./assets/react.svg\";\nimport viteLogo from \"/vite.svg\";\nimport \"./App.css\";\nimport { ButtonSignIn } from \"@dippixyz/react-sdk\";\nimport \"@dippixyz/react-sdk/index.css\";\n\nfunction App() {\n  return (\n    &lt;&gt;\n      &lt;div className=\"card\"&gt;\n        &lt;ButtonSignIn /&gt;\n      &lt;/div&gt;\n    &lt;/&gt;\n  );\n}\n\nexport default App;\n</code></pre></li> <li>Remove unused imports on lines 1 through 3 from <code>src.App.tsx</code>. Your code should look like this now:   <pre><code>import \"./App.css\";\nimport { ButtonSignIn } from \"@dippixyz/react-sdk\";\nimport \"@dippixyz/react-sdk/index.css\";\n\nfunction App() {\n  return (\n    &lt;&gt;\n      &lt;div className=\"card\"&gt;\n        &lt;ButtonSignIn /&gt;\n      &lt;/div&gt;\n    &lt;/&gt;\n  );\n}\n\nexport default App;\n</code></pre></li> <li>Run your application by typing the following in your terminal:   <pre><code>npm run dev\n</code></pre>   You should see the Dippi Sign in button on the screen. Test out the functionality, sign up, create a wallet, encrypt the private key and login to your application. 13. Once you've got the login setup, you can use the rest of our components and take advantage of the Dippi context to protect your application. We're going to add the sign and send transaction functionality to your application. First, you need to import the <code>TransactionForm</code> component into <code>src/App.tsx</code>.   <pre><code>import { TransactionForm } from \"@dippixyz/react-sdk\";\n</code></pre>   The <code>TransactionForm</code> receives props that can vary according to the Web3 provider that you selected. For the time being we are supporting all providers currently supported by Ethers v6: Alchemy, Ankr, Cloudflare, Etherscan, Infura, Pocket, QuickNode.   Click on any of the providers to get your API key and project id which should be passed as a prop to the provider of your choice. For the sake of this guide we will be using Alchemy.   Add the <code>TransactionForm</code> component to <code>src/App.tsx</code> on line 10 and send the <code>_network</code> (can be the chain id or the name of the network eg.: <code>1</code> or <code>Mainnet</code>), <code>provider</code> (e.g.: <code>Alchemy</code>) and <code>apiKey</code>.   <pre><code>&lt;TransactionForm _network={1} provider={\"Alchemy\"} apiKey=\"Your API key\" /&gt;\n</code></pre></li> </ol> <p>Note</p> <p>The <code>apiKey</code> may also be called <code>_apiKey</code>, <code>projectSecret</code>, or <code>applicationSecret</code> according to the provider you selected and can also be paired with an <code>applicationId</code> or <code>projectId</code>.</p>"},{"location":"guides/Frontend_SDKs/frontend_react/#voila-dippi-and-your-app-should-work-like-magic-now","title":"Voil\u00e1! Dippi and your app should work like magic now!","text":"<p>Thanks for following this tutorial. Got suggestions? Don\u2019t hesitate and let us know \ud83e\udd13</p>"},{"location":"technology/","title":"Introduction","text":"<p>Let's start with a one line definition for our protocol:</p> <p>Security Labs Key Management Protocol</p> <p>Security Labs Key Management Protocol (sLabs KMP) is a Permission-less peer-to-peer network protocol for key management.</p> <p>Key management refers to the additional set of responsibilities users are given as a cost of managing their identity themselves: an unavoidable side effect of decentralization in Web3. This set of responsibilities are attached to not losing some cryptographic token, about which we talk more here, but in a nutshell is any data that allows someone to have identity inside some set of agents and access-control and operation over some set of resources shared among.</p>"},{"location":"technology/#permission-less","title":"Permission-less","text":"<p>To be a permission-less network means to be open for everyone to participate as a node, by just following the specifications to be one; there is no central authority who can modify the state and operations of the network, nor it is necessary to \"ask for permission\" to (i.e. get approved by) said central authority.</p> <p>This property is important since managing cryptographic tokens ourselves is a core desirable property of web3 systems: to preserve users' autonomy over their identity, data and operations.</p>"},{"location":"technology/#key-management-abstraction","title":"Key Management Abstraction","text":"<p>Key Management Abstraction (KMA) let anyone store cryptographic tokens for later retrieval through simple and intuitive authentication interface to mitigate risk currently associated to private keys:</p> <ol> <li>Loss risk: Risk of losing your private key, losing in the process access to all associated assets.</li> <li>Theft risk: Risk of your private key being held by another unintended person/agent, which could imply loss of assets or inappropriate use of identity, even if you still hold access to them yourself.</li> <li>Unavailability risk: Risk of private key not being available in some specific dApp context, commonly when choosing a different browser or device.</li> <li>Usability risk: Risk of getting users stuck on the dApp user-flow due to export/import or other managing aspects of the private key, commonly encountered when trying to use different devices or dApps with what could be interpreted by the user as \"the same account\", but really being subtly more complicated under-the-hood due to Web3's nature.</li> </ol> <p>We abstract key management operations like private key storage and retrieval by expressing users' identities over a decentralized and permission-less infrastructure as a map between intuitive authentication methods (i.e. traditional web2 authentication, preferably biometrics, behavior-based and hardware-based) to cryptographic tokens.</p> <p>Next Steps: State Observing Network</p> <p>Key management abstraction is achieved by our State Observing Network, an ephemeral mix network strategy to over a peer-to-peer infrastructure which coordinates securely the storage for state change authentication to map intuitive and familiar authentication methods to secure decentralized and cryptographic methods. Read more on this high-level view, or in our whitepaper</p>"},{"location":"technology/overview/","title":"Important Concepts","text":"<p>The following is a reference list for commonly used and/or core concepts in Security Labs. For a more guided tour around out technology and theoretical concepts, visit here </p>"},{"location":"technology/overview/#cryptographic-token","title":"Cryptographic token","text":"<p>by cryptographic token we mean any piece of organized data which serves the purpose of singling out some property to just one entity (person, agent, etc; depending on the context), usually with cryptographic guarantees that it only belongs to that entity; i.e. cryptographic binding. </p> <p>For example, a private key in a public-key cryptosystem attributes the keyholder a unique ability to produce signed messages. The cryptographic binding here is the computational intractability of forging a signature if you're not the keyholder. The same applies to delegated signing keys or Decentrally generated keys. Cryptographic tokens are the basis for decentralizing identity, access control and operations in Web3, but are also the source of the trade-off between Web3 benefits and usability.</p> <p>Not all cryptographic tokens needs to be decentralized, though: Simple username and password pairs on a centralized database are one example, since they give access control based on the central authority's backend rules to each specific user. Here we have binding which depends on the trust on said centralized party.</p> <p>In general, we called them \"cryptographic\" since their structure hides information that allow asymmetric capabilities to the holders, and losing them means losing said capabilities.</p>"},{"location":"technology/overview/#usability","title":"Usability","text":"<p>It's common to say that Web3 has an \"onboarding\" problem, referring to the process of bringing new users into some specific user experience, but frequently leaving aside the fact that, even if onboarded, dApps' user experience by itself is lacking proper polish. When we talk about good usability on Security Labs, we refer to the property of a dApp to allow its users to operate without any special knowledge (about private keys, blockchain, tokens, etc.) with web2-like UX.</p>"},{"location":"technology/overview/#key-management-abstraction","title":"Key Management Abstraction","text":"<p>Key Management Abstraction (KMA) let anyone store cryptographic tokens for later retrieval through simple and intuitive authentication interface to mitigate risk currently associated to private keys: </p> <ol> <li>Loss risk: Risk of losing your private key, losing in the process access to all associated assets.</li> <li>Theft risk: Risk of your private key being held by another unintended person/agent, which could imply loss of assets or inappropriate use of identity, even if you still hold access to them yourself.</li> <li>Unavailability risk: Risk of private key not being available in some specific dApp context, commonly when choosing a different browser or device.</li> <li>Usability risk: Risk of getting users stuck on the dApp user-flow due to export/import or other managing aspects of the private key, commonly encountered when trying to use different devices or dApps with what could be interpreted by the user as \"the same account\", but really being subtly more complicated under-the-hood due to Web3's nature.</li> </ol> <p>We abstract key management operations like private key storage and retrieval by expressing users' identities over a decentralized and permission-less infrastructure as a map between intuitive authentication methods (i.e. traditional web2 authentication, preferably biometrics, behavior-based and hardware-based) to cryptographic tokens.</p>"},{"location":"technology/overview/#state-change-authentication-scheme","title":"State change authentication scheme","text":"<p>Described more deeply and technically on our whitepaper, State Change Authentication Schemes (SCAS) is a family of authentication methods designed by Security Labs to fully describe how traditional authentication schemes can leverage decentralized systems properties to add a decentralization-driven security layer over intuitive UX to which users are already familiar. </p> <p>These provide an interface data structure called State Change Authentication Token (SCAT), inside which general authentication information is stored mixed with a cryptographic token shard, allowing the network to pinpoint securely when to react to retrieval requests. Any authentication method, like traditional biometrics, hardware-based, password/pin-based, etc. can be used to interface with SCAS throught a SCAT to provide decentralized protection without jeopardizing already accepted user-experience.</p>"},{"location":"technology/overview/#state-change-authentication-token","title":"State-Change Authentication Token","text":"<p>Our own cryptographic data-structure in charge of holding shares of cryptographic tokens to be secured along with enough authentication information for observers (our network nodes) to authenticate users through a challenge-response procedure, verified distributively across several of them, without jeopardizing its contents.</p> <p>Apart from the cryptographic token share, coming from a perfect-security splitting procedure and further secured, it contains standardized information about the authentication token (e.g. biometric data, hardware key, etc.) as a dynamical system's state space being evolved uniquely by said token, providing a general framework for time-distributed authentication methods (e.g. behavioral biometrics, on-chain identity, etc.). </p>"},{"location":"technology/overview/#decentralization-driven-security","title":"Decentralization-driven security","text":"<p>Decentralization comes with several benefits, few obvious ones such as data redundancy and integrity, robustness against some attacks that would be very effective against single points of failure, etc. Nevertheless, its security (meaning, its resistance against behaving unexpectedly, given the effort of an adversary) is usually based solely on cryptographic primitives with fixed security levels given a threat model and chosen parameters.</p> <p>This is by no means bad or weak in most cases, but it doesn't always scale naturally with the system size. Sometimes even on the contrary, scaling some networks can make them less secure by exposing more \"weak links\". When a system scales its security level along with its size, we call it decentralizartion-driven security, and it's a security property we designed our network to have.</p>"},{"location":"technology/overview/#token-bound-accounts","title":"Token Bound Accounts","text":"<p>Token Bound Accounts, abbreviated TBA, are the result of a smart-contract-based strategy to append account functionality (assets holding and transferring) to Non-Fungible Tokens. This is done through a permission-less and owner-less registry contract which assign proxy interfaces for account operations when called (signed) by the NFT owner. </p> <p>This has several use cases such as:</p> <ol> <li>Dynamic Gaming Avatars: ERC-6551-enabled NFTs in online multiplayer games serve as dynamic avatars, representing players' in-game achievements, items, and reputation within the gaming community. These avatars evolve as players progress, reflecting their growing reputation.</li> <li>Music Album NFTs: Musicians release NFT albums that collectors can expand over time with new tracks. Reputation is based on the artist's recognition, track rarity, and collector engagement, such as reviews or recommendations.</li> <li>Digital Identity and Passports: ERC-6551-backed NFTs serve as digital identity passports, accumulating reputation points based on online interactions, contributions to Decentralized Autonomous Organizations (DAOs), and participation in online events.</li> <li>DeFi Smart Profiles for Traders: Traders use NFTs with ERC-6551 to create dynamic trading profiles, including historical performance and strategies. Other traders assess the reputation of these profiles to decide whether to buy strategies or collaborate.</li> <li>Decentralized Content Creation: Content creators mint NFTs representing their work, such as articles or artwork. These NFTs accrue reputation points based on views, likes, and engagement, allowing users to co-create and personalize content.</li> <li>DAO Participation Badges: NFTs with ERC-6551 are awarded to active participants in Decentralized Autonomous Organizations (DAOs). Holding these badges provides voting power and influence in decentralized governance.</li> <li>Airdrop Facilitation: NFTs equipped with ERC-6551 facilitate efficient and targeted airdrops. Projects distribute tokens or assets based on reputation or community involvement, ensuring airdrops reach genuinely engaged users.</li> <li>Asset-Based Reward Systems: NFTs with ERC-6551 enable asset-based reward systems for content creators or project contributors. Streaming rewards or revenue shares are sent directly to NFT-backed addresses, simplifying income distribution.</li> <li>Interoperable Reputation Scores: ERC-6551 can be adapted for cross-chain functionality, allowing reputation and assets to flow seamlessly across different blockchain networks.</li> <li>Community-Based Governance: NFTs representing governance tokens use ERC-6551 to enhance community-based decision-making processes. Users with higher reputation scores gain more influential voting power in decentralized governance.</li> <li>Trustworthy Identity Verification: NFT-backed identities with ERC-6551 are used for trust verification across services and platforms, particularly valuable for Know Your Customer (KYC) processes.</li> </ol>"},{"location":"technology/state_observing_network/","title":"State observing network","text":""},{"location":"technology/state_observing_network/#state-observing-network","title":"State Observing Network","text":"<p>From the user's perspective, our state-observing network can be simplified to just an interface to store and retrieve private keys (or, more generally, cryptographic tokens). This happens in three steps: </p> <ol> <li>Pre-processing</li> <li>Network processing</li> <li>Authentication and retrieval</li> </ol> <p>The initial conditions for this process are the user's key they desire to protect, and a SCAS-compatible authentication process. </p> <p></p> <p>A bit more detailed walkthrough for each step breaks down each as follows:</p>"},{"location":"technology/state_observing_network/#1-pre-processing","title":"1. Pre-processing","text":"<p>The following are done securely on client-side:</p> <p>a. Splitting: The key shards and identity-authentication information is securely split by using Shamir-secrets-sharing (SSS), chosen for its perfect (information-theoretic) security guarantees. </p> <p>b. Structuring: Refers to the process of building the SCAT, which basically involves protecting both, key shard and ID shard, as well as a homomorphically encrypted authentication instructions for the auth &amp; challenge process by using encryption only breakable with a brute-force approach expected from the client during retrieval. This is not computationally intractable neither does it affect UX. It only serves the purpose of making it intractable for an attacker to try many key shard combinations at scale.</p> <p>c. Delivering: Each SCAT is sent into the State Observing Network with onion layering being done. That is, the network is queried for its current chosen ephemeral sub mix net (which changes randomly and unpredictably to prevent enough time for well-designed collusion attacks) and the client-side prepared an onion message to be sent into the network for mixing.</p>"},{"location":"technology/state_observing_network/#2-network-processing","title":"2. Network Processing","text":"<p>a. Mixing: SCATs' traffic is mixed such that no correlation of their origin can be traced back, specially after being appended to other messages in form of a final batch to be delivered to the indented storage node (randomly selected by client-side).</p> <p>b. Storing: The storage is being done efficiently to optimize for retrieval requests checking performance by using Bloom filters and intelligent sampling, as well as disk space, to reduce costs while preserving security.</p> <p>c. State Consensus: The underlying peer-to-peer network manages global variables such as nodes reliability, current staking quantities, past success rates and other behavioral metrics to prioritize network services quality. Said state must be distributed by using a staking mechanism, which as additionally used to prioritize (partially, to preserve significant levels of true randomness) being selected for network services participation.</p>"},{"location":"technology/state_observing_network/#3-authentication-and-retrieval","title":"3. Authentication and retrieval","text":"<p>a. Challenging: A retrieval request contains information which matches a subset of storage nodes which not all correspond to the sought SCATs', to introduce ambiguity. This match is done via public, but secure, global data on the P2P net. Each matched node calls their state-shared group to initiate a challenge process.</p> <p>A challenge is a call to the retrieval requester to provide some significant score in a statistical test against the state information each shared-state group has. This is done using MPC. Only one randomly-selected (based on a staking-mechanism) member of the group makes up the challenge.</p> <p>b. Responding: Each state-shared group will notify the storage node of the challenge result and - if positive - the storage node will send its shard to the requester. Since responses are independent, the shards will arrive to the user in at random times and in random order; with no obvious information on how to reconstruct the key. This is intended for security reasons.</p> <p>The user will have to reconstruct the key from the shards in a local brute-force procedure, from which is computationally intractable to extract information from even if only one shard is missing.</p> <p></p> <p>Next Steps: Threat model</p> <p>Each part of the process can be analyzed for security using threat modelling, a conceptual and measurable framework to describe the risk our system is exposed to, behind which specific conditions and assumptions. See Threat model for more.</p>"},{"location":"technology/threat_model/","title":"Threat model","text":""},{"location":"technology/threat_model/#introduction","title":"Introduction","text":"<p>A threat model involves describing the following aspects:</p> <ol> <li>System objective: All threat models must begin with an understanding of what the system is intended to do. Most commonly, said intended purpose is to support agents interacting with the system, and the threats come from the possible actions the agents are allowed to do over some set of assets, constrained by system rules.</li> <li>Security definition: We need to define what we exactly mean when we say \"we are a secure network\", preferably in a measurable way. This is done by defining the resources we are trying to protect and properties we are trying to ensure, the ways and extend in which these are being endangered, with respect to the previously stated system objective.</li> <li>Adversary objectives: Given the guarantees defined in our security concept, we then must describe the adversary objectives. This may be acquiring some total information (e.g. stealing either a specific target private key, or any private key), or partial information (like progressively learning the locations of specific shards); or may be affecting some network services (the storage, retrieval and/or mixing), either by stopping them, only interrupting them, or spoofing them.</li> <li>Computational resources assumptions for the adversary: The adversary is defined by their goals, and hence their incentives, but also their computational resources that will imply some cost of seeking their objective. If this cost, given their computational resources, is too high compared with the incentives, we can assume a lower number (in practice) of adversaries matching that specific attack. Keeping consideration of this number may be specially important when analyzing decentralization-driven security.</li> </ol>"},{"location":"technology/threat_model/#threat-model","title":"Threat model","text":""},{"location":"technology/threat_model/#system-objective","title":"System Objective","text":"<p>The State Observing Network's objective is simple: </p> <p>State Observing Network objective</p> <p>Store Cryptographic tokens (e.g. private keys) in a decentralized, permission-less, trust-less and highly available way, keeping them retrievable through familiar, but flexibly more robust, authentication methods.</p> <p>In many complex and hierarchical system, we can pinpoint many agent types: Administrators, read-only user, differently limited operators, etc. </p> <p>Luckily, in peer-to-peer systems, agent interactions tends to be more symmetric. In the case of Security Labs, we have a few roles one node can be acting in, but symmetry still exists in the sense that each role can be attained by any node without preference in an unpredictable (and thus uncontrollable) way. </p> <p>We have the following table explaining them:</p> Role Task Storage Node Stores SCAT securely and in a uncorrelated way. Challenger Node Challenge making, with MPC within share-state groups and independent challenge verification over homomorphically encrypted data. Entrypoint Node Receive storage and retrieval requests and acts accordingly updating and broadcasting global network state (by consensus procedure) and re-send data packets through the currently valid mixnet. Mixnet Node In charge of receiving and re-sending onion messages, \"peeling\" onion layers by decrypting them before re-sending to the appropriate next node. Pseudo-storage Node Acts as a storage node to add entropy by noise in the network operations, being unable themselves to know if they are participating in a true storing procedure or not."},{"location":"technology/threat_model/#security-definition-and-adversary-objectives","title":"Security Definition and Adversary Objectives","text":"<p>Let's define specific threats and their associated property at risk:</p> Threat What is it threatening? Explanation and adversary objective Spoofing Authenticity Your private key should not be retrievable by no one else. Tampering Integrity Your private key should be available even against unreliable and adversarial nodes. Data leak Confidentiality Key shards should be impossible to intercept and extract information from during traffic and when stored. This includes even partial statistical information, with enough significance to make tractable a short to middle term (~100 years) expected reconstruction of the key. Denial of service Availability We are requiring specific availability assumptions about the following network services:  1. Storage requests: Storage should be resistant to being forced to stop, however we are allowing slowing down of storage requests inside some reasonable (from the UX perspective) threshold, since slowing down may come not only from direct attacks, but as fluctuations on supply &amp; demand, which are natural.  2. Retrieval requests: As the main mechanism for private key availability, we require a stricter threshold for allowed slowing than storage requests, but otherwise, the same applies as before.  3. Mixing: Since mixing ensures decentralization-driven security, we expect not only for it to always fully work, but to be immune to spoofing attacks in the sense that a big enough entity should not be able to impersonate enough nodes in the network such that the whole network operation becomes faulty."},{"location":"technology/threat_model/#general-countermeasures","title":"General countermeasures","text":"<p>The following describes point-by-point security countermeasures for the mentioned risks:</p> <ul> <li>Spoofing: The SCAT leverages Shamir secret sharing (SSS) to introduce threshold security/redundancy with perfect (information theoretic) security guarantees. That means that, even when some shards (less than the total) are in hands of the adversary, it is impossible to recover the original key (except, of course, by a brute force search in the complete key space, which is always possible anyway).</li> <li>Tempering: As explained on several security-related theorems in our whitepaper, there is network scale beyond which the network is always resistant (equivalently to a 256-resistance in traditional cryptography) to collusion attacks even of 99% of the network, ensuring resistance against directly adversarial parties. Now, for passive adversaries like unreliable nodes, there is a dynamic measure of redundancy, where the number of redundant nodes for each SCAT is increased (or decreased) in proportion to the success rate of retrieval and storage requests.</li> <li>Data Leak: The SCATs' batch preparation and mixing during the storage flow ensures data is not leaked during data traffic and the whole storage lifetime. </li> <li>Denial of Service: General availability guarantees are protected by the staking and rating mechanisms, based on several global metrics of past successful behavior of the network. The spoofing during mixing is protected again by the scale of the network (past 6k nodes to ensure 256-bit strength against 99%-sized collusion attacks)</li> </ul>"}]}